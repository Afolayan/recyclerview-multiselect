{"name":"RecyclerView MultiSelect","tagline":"RecyclerView MultiSelect is a tool to help implement single or multichoice selection on RecyclerView items","body":"RecyclerView MultiSelect is a tool to help implement single or multichoice selection on RecyclerView items. It does not provide the same interface as ListView's setChoiceMode(), but can do everything setChoiceMode() does. It is also small with a limited set of responsibilities, which means it should be suitable for coercing into off label uses.\r\n\r\n<a href=\"http://www.methodscount.com/?lib=com.bignerdranch.android%3Arecyclerview-multiselect%3A%2B\"><img src=\"https://img.shields.io/badge/Methods and size-core: 118 | deps: 14762 | 23 KB-e91e63.svg\"></img></a>\r\n\r\n## Overview\r\n\r\n![multiselect sample](multiselect_sample.gif)\r\n\r\n\r\n### Basics\r\n\r\nThe MultiSelector is the core object that manages multi-selection. However, you have to tell MultiSelector when to enter/leave selection mode.\r\n\r\n```\r\nMultiSelector multiSelector = new MultiSelector();\r\nmultiSelector.setSelectable(true); // enter selection mode\r\n```\r\n\r\n```\r\nMultiSelector multiSelector = new MultiSelector();\r\nmultiSelector.setSelectable(false); // leave selection mode\r\n```\r\n\r\nYou must also tell MultiSelector when an item has been selected.\r\n\r\n```\r\nMultiSelector multiSelector = new MultiSelector();\r\nmultiSelector.setSelectable(true); // enter selection mode\r\nmultiSelector.setSelected(myViewHolder, true); // set myViewHolder to selected\r\n```\r\n\r\nYour ViewHolder must implement the SelectableHolder interface. This library provides a default implementation called SwappingHolder that handles the visuals of being selected/unselected.\r\n\r\n\r\n```\r\nprivate MultiSelector mMultiSelector = new MultiSelector();\r\n\r\nprivate class MyViewHolder extends SwappingHolder \r\n            implements View.OnLongClickListener { // (1)\r\n\r\n    public MyViewHolder(View itemView) {\r\n        super(itemView, mMultiSelector); // (2)\r\n        itemView.setLongClickable(true);\r\n    }\r\n\r\n    @Override\r\n    public boolean onLongClick(View view) { // (6)\r\n        if (!mMultiSelector.isSelectable()) { // (3)\r\n            mMultiSelector.setSelectable(true); // (4)\r\n            mMultiSelector.setSelected(MyViewHolder.this, true); // (5)\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n```\r\n\r\nCreate a ViewHolder that subclasses SwappingHolder (1). MultiSelector works through the SelectableHolder interface to communicate to the ViewHolder when it has been selected/deselected. Therefore you must pass MultiSelector to SwappingHolder in the ViewHolder's constructor (2). Ensure MultiSelector is not already in selection mode (3), then enter selection mode (4). Finally set the item as selected (5). In this example, we chose to enter selection mode on long press (6). It is up to you to decide what triggers selection mode.\r\n\r\nIt is also up to you to notify MultiSelector when an item is clicked during selection mode. However, you will want to notify MultiSelector only during selection mode. When not in selection mode you can handle item clicks normally. \r\n\r\nThis library provides a convenience method called tapSelection(). If MultiSelector is in selection mode, this method will toggle the selected state of an item and return true. If MultiSelector is not in selection mode this method returns false.\r\n\r\n```\r\nprivate class MyViewHolder extends SwappingHolder implements View.OnClickListener {\r\n\r\n    public MyViewHolder(View itemView) {\r\n        super(itemView, mMultiSelector);\r\n    }\r\n\r\n    @Override\r\n    public void onClick(View view) {\r\n        if (!mMultiSelector.tapSelection(MyViewHolder.this)){\r\n            // do whatever we want to do when not in selection mode\r\n            // perhaps navigate to a detail screen\r\n        }\r\n    }\r\n    \r\n    ...\r\n}\r\n```\r\n\r\nIf you want to enter ActionMode as part of selection mode, it is your responsibility to do so. However this library provides a helper ActionMode.Callback helper class called ModalMultiSelectorCallback.\r\n\r\n\r\n```\r\nprivate MultiSelector mMultiSelector = new MultiSelector();\r\n\r\nprivate ModalMultiSelectorCallback mActionModeCallback \r\n        = new ModalMultiSelectorCallback(mMultiSelector) { // (1)\r\n    ...\r\n};\r\n\r\nprivate class MyViewHolder extends SwappingHolder\r\n        implements View.OnClickListener, View.OnLongClickListener {\r\n\r\n\t...\r\n\t\r\n    @Override\r\n    public boolean onLongClick(View view) {\r\n        if (!mMultiSelector.isSelectable()) {\r\n            ((AppCompatActivity) getActivity()).startSupportActionMode(mActionModeCallback); // (2)\r\n            mMultiSelector.setSelectable(true);\r\n            mMultiSelector.setSelected(MyViewHolder.this, true);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n```\r\n\r\nFirst create an instance of ModalMultiSelectorCallback, passing in your MultiSelector (1). Then pass this callback into the system when starting ActionMode (2).\r\n\r\nThe ModalMultiSelectorCallback exposes all methods in the ActionMode.Callback interface that you would normally use to create/prepare/respond to/destroy the ActionMode menu items:\r\n\r\n```\r\npublic boolean onCreateActionMode(ActionMode mode, Menu menu);\r\n\r\npublic boolean onPrepareActionMode(ActionMode mode, Menu menu);\r\n\r\npublic boolean onActionItemClicked(ActionMode mode, MenuItem item);\r\n\r\npublic void onDestroyActionMode(ActionMode mode);\r\n```\r\n\r\nFor this example, we use want to delete items in selection/action mode:\r\n\r\n```\r\nprivate ModalMultiSelectorCallback mActionModeCallback\r\n        = new ModalMultiSelectorCallback(mMultiSelector) {\r\n\r\n    @Override\r\n    public boolean onCreateActionMode(ActionMode actionMode, Menu menu) {\r\n        super.onCreateActionMode(actionMode, menu);\r\n        getActivity().getMenuInflater().inflate(R.menu.list_context_menu, menu);\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public boolean onActionItemClicked(ActionMode actionMode, MenuItem menuItem) {\r\n        if (menuItem.getItemId() == R.id.menu_item_delete) {\r\n            actionMode.finish();\r\n\r\n            for (int i = mObjects.size(); i >= 0; i--) {\r\n                if (mMultiSelector.isSelected(i, 0)) { // (1)\r\n                    // remove item from list\r\n                    mRecyclerView.getAdapter().notifyItemRemoved(i);\r\n                }\r\n            }\r\n\r\n            mMultiSelector.clearSelections(); // (2)\r\n            return true;\r\n\r\n        }\r\n        return false;\r\n    }\r\n};\r\n```\r\n\r\nWe can access each selected item (1) to remove it from our list. We also need to clear selection when finished removing all items (2).\r\n\r\n### Single Selection\r\n\r\nTo use single selection instead of multiselect, use SingleSelector instead of MultiSelector:\r\n\r\n```\r\nprivate MultiSelector mMultiSelector = new SingleSelector();\r\n```\r\n\r\n![single select sample](singleselect_sample.gif)\r\n\r\n## Customizing Selection Visuals \r\n\r\nSwappingHolder uses two sets of drawables and state list animators for its itemView: one while in the default mode, and one while in selection mode. You can customize these by calling one of the various setters:\r\n\r\n```\r\npublic void setSelectionModeBackgroundDrawable(Drawable drawable);\r\npublic void setDefaultModeBackgroundDrawable(Drawable drawable);\r\n\r\npublic void setSelectionModeStateListAnimator(int resId);\r\npublic void setDefaultModeStateListAnimator(int resId);\r\n```\r\n\r\nThe state list animator setters are safe to call prior to API 21, and will result in a no-op.\r\n\r\n### Off Label Customization\r\n\r\nIf you need to customize what the selected states look like beyond what SwappingHolder offers, you can extend the MultiSelectorBindingHolder abstract class to respond to selection events:\r\n\r\n```\r\npublic class MyCustomHolder extends MultiSelectorBindingHolder {\r\n    @Override\r\n    public void setSelectable(boolean selectable) { ... }\r\n\r\n    @Override\r\n    public boolean isSelectable() { ... }\r\n\r\n    @Override\r\n    public void setActivated(boolean activated) { ... }\r\n\r\n    @Override\r\n    public boolean isActivated() { ... }\r\n}\r\n```\r\n\r\nIf that's still too restrictive, you can implement the SelectableHolder interface instead:\r\n\r\npublic interface SelectableHolder {\r\n    void setSelectable(boolean selectable);\r\n    boolean isSelectable();\r\n\r\n    void setActivated(boolean activated);\r\n    boolean isActivated();\r\n\r\n    int getAdapterPosition();\r\n    long getItemId();\r\n}\r\n\r\nIt requires a bit more code: you will need to bind your ViewHolder to the MultiSelector by calling MultiSelector.bindHolder() every time your view holder is bound to a different item. On the other hand, though, your implementation doesn't even necessarily have to be hooked up to a RecyclerView, and neither does your MultiSelector. I have no idea how useful that is to anyone, but there you go.\r\n\r\n\r\n\r\n##Download\r\n\r\n[v0.2 AAR](http://central.maven.org/maven2/com/bignerdranch/android/recyclerview-multiselect/0.2/recyclerview-multiselect-0.2.aar)\r\n\r\n**Gradle**\r\n\r\n```\r\ncompile 'com.bignerdranch.android:recyclerview-multiselect:0.2'\r\n```\r\n\r\n**Maven**\r\n\r\n```\r\n<dependency>\r\n\t<groupId>com.bignerdranch.android</groupId>\r\n\t<artifactId>recyclerview-multiselect</artifactId>\r\n\t<version>0.2</version>\r\n</dependency>\r\n```\r\n\r\n##Documentation\r\n\r\nvisit the [java docs](/javadocs)\r\n\r\n##Contributing\r\n###Issues or Comments\r\n\r\nIf you have an idea for a feature enhancement or a bug fix, we'd love to know! We handle issue tracking using GitHub's issue system, so feel free to add your comment there. \r\n\r\n###Updates and Fixes\r\nWe also welcome all pull requests. Please open your pull request against master. We really love [good commit messages](http://chris.beams.io/posts/git-commit/) and atomic commits.\r\n\r\n##License\r\n```\r\nThe MIT License (MIT)\r\n\r\nCopyright (c) 2014 Big Nerd Ranch\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}